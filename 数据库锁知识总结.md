## 数据库锁知识总结
### 锁的作用
数据库是多用户使用的共享资源。在高并发的情况下，如果多个事务同时操作同一数据，如果不加控制，就可能会读取或保存不正确的数据，破坏数据库的一致性。锁就是为了解决这种问题而生的。
### 锁的等级及区别
- 表级锁  
开销小，加锁快；不会出现死锁；锁定颗粒度大，发生锁冲突的概率最高，并发度最低。
- 页面锁  
开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。
- 行级锁  
开销大，加锁慢；会出现死锁；锁定粒度最小，发生冲突的概率最低，并发度最高。
### 乐观锁  
总是假设最好的情况，每次去那数据的时候都认为别人不会修改，所以不会上锁，但是在更新的饿时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机智和CAS算法实现。乐观锁适用于多度的应用类型，这样可以提高吞吐量。
### 悲观锁
总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其他线程阻塞，用完后再把资源转让给其他线程）。
### 共享锁
共享锁又称读锁（read lock），是读取操作创建的锁。其他用户可以并发读取数据，但任何事物都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。当如果事物对读锁进行修改操作，很可能会造成死锁。
### 排他锁
排他锁(exclusive lock)又称为写锁(writer lock)。若某个事务对其进行读写，在此事务结束之前，其他事务不能对其进行任何锁，其他进程可以读取不能进行写操作，需要等待其释放。排它锁是悲观锁的一种实现。
### 间隙锁
当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给复核条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做间隙(gap),InnoDB也会对这个间隙加锁，这种锁机制就是所谓的间隙锁(Next-Key锁)。
### 死锁
死锁（Deadlock）所谓死锁：数据库是一个多用户使用的共享资源，当多个用户并发存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况，若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据的一致性。加锁是事先数据库并发控制的一个非常重要的技术。在实际应用中经常会遇到与锁相关的异常情况，当两个事务需要一组体验吃办公厅于的锁，而不能讲事务继续下去的话，就会出现死锁。
## 参考
[全面了解mysql锁机制（InnoDB）与问题排查](全面了解mysql锁机制（InnoDB）与问题排查)  
[面试必备之乐观锁与悲观锁](https://juejin.im/post/6844903639207641096)  
[数据库常见死锁原因及处理](https://blog.csdn.net/qq_16681169/article/details/74784193)  