## 脏读、幻读、不可重复读和可重复读
### 数据库事务特征
> 即ACID
- A Atomicity 原子性  
事务是一个原子性质的操作单元，事务里面的对数据库的操作要么都执行，要么都不执行
- C Consisteng 一致性  
在事务开始之前和完成之后，数据都必须保持一致状态，必须保证数据库的完整性。
- I Islation 隔离性  
数据库允许多个并发事务同时对数据进行操作，隔离性保证各个事务相互独立，事务处理时的中间状态对其他事务是不可见的，以此防止出现数据不一致状态。
- D Durable 持久性  
一个事务处理结束后，其对数据库的修改就是永久性的，即使系统故障也不会丢失。
### MySQL数据隔离级别
| 隔离级别 | 脏读（Dirty Read） | 不可重复读（NonRepeatable Read） | 幻读（Phantom Read） |
| --- | --- | --- | --- |
| 未提交读（Read  uncommitted） | 可能 | 可能 | 可能 |
| 已提交读（Read committed） | 不可能 | 可能 | 可能 |
| 可重复读（Repeatable read） | 不可能 | 不可能 | 可能 |
| 可串行化（Serializable ） | 不可能 | 不可能 | 不可能 |
- Read uncommitted（未提交读）  
允许脏读，也就是可能读取到其他会话中未提交事务修改的数据
- Read committed（提交读）  
只能读取已经提交的数据
- Repeatable read（可重复读）  
在同一个事务内的查询都是事务开始时一致的
- Serializable（串行读）
完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。
### 脏读  
脏读是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。
### 不可重复读
是指在一个事务内，多次读统一数据。在这个事务还没有技术时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次督导的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。
### 可重复读
可重复读(Repeatable Read)，当使用可重复读隔离级别时，在事务执行期间会锁定该事务以任何方式引用的所有行。因此，如果在同一个事务中发出同一个SELECT语句两次或更多次，那么产生的结果数据集总是相同的。因此，使用可重复读隔离级别的事务可以多次检索同一行集，并对它们执行任意操作，直到提交或回滚操作终止该事务。
### 幻读
第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好像发生了幻觉一样。